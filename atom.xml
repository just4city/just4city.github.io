<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://just4city.github.io</id>
    <title>Gridea</title>
    <updated>2019-11-20T06:34:05.223Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://just4city.github.io"/>
    <link rel="self" href="https://just4city.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://just4city.github.io/images/avatar.png</logo>
    <icon>https://just4city.github.io/favicon.ico</icon>
    <rights>All rights reserved 2019, Gridea</rights>
    <entry>
        <title type="html"><![CDATA[vue-cli3.0项目使用proxy跨域]]></title>
        <id>https://just4city.github.io/post/vue-cli30-xiang-mu-shi-yong-proxy-kua-yu</id>
        <link href="https://just4city.github.io/post/vue-cli30-xiang-mu-shi-yong-proxy-kua-yu">
        </link>
        <updated>2019-11-20T06:32:07.000Z</updated>
        <content type="html"><![CDATA[<p>通过vue-cli3.x版本构建的项目使用proxy和以前的项目不同，而且3.x版本构建的时候可以选用typescript了。下面记录一下如何使用proxy跨域。<br>
首先在根目录创建vue.config.js文件，这个配置文件在运行项目的时候自动加载。</p>
<pre><code class="language-javascript">// vue.config.js
module.exports = {
  devServer: {
    proxy: {
      '/api': {
        target: 'http://xxxx/device/', //对应自己的接口
        changeOrigin: true,
        ws: true,
        pathRewrite: {
          '^/api': ''
        }
      }
    }
  }
}

</code></pre>
<p>请求:</p>
<pre><code class="language-javascript">axios.get('/api/getDataPoint').then(res =&gt; {
  console.log(res)
})
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[nginx 同一个域名下部署多个工程]]></title>
        <id>https://just4city.github.io/post/nginx-tong-yi-ge-yu-ming-xia-bu-shu-duo-ge-gong-cheng</id>
        <link href="https://just4city.github.io/post/nginx-tong-yi-ge-yu-ming-xia-bu-shu-duo-ge-gong-cheng">
        </link>
        <updated>2019-11-19T14:26:24.000Z</updated>
        <content type="html"><![CDATA[<p>https://blog.csdn.net/chenhuaping007/article/details/79997901</p>
<p>https://juejin.im/post/5cfe23b3e51d4556f76e8073</p>
<p>https://juejin.im/post/5d7b72b7e51d453b386a63bc</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Docker run 命令参数及使用]]></title>
        <id>https://just4city.github.io/post/docker-run-ming-ling-can-shu-ji-shi-yong</id>
        <link href="https://just4city.github.io/post/docker-run-ming-ling-can-shu-ji-shi-yong">
        </link>
        <updated>2019-11-19T09:08:44.000Z</updated>
        <content type="html"><![CDATA[<h4 id="docker-run-创建一个新的容器并运行一个命令">Docker run ：创建一个新的容器并运行一个命令</h4>
<pre><code class="language-bash">docker run [OPTIONS] IMAGE [COMMAND] [ARG...]  
</code></pre>
<p>OPTIONS说明：</p>
<pre><code class="language-bash">Usage: docker run [OPTIONS] IMAGE [COMMAND] [ARG...]    

-d, --detach=false         指定容器运行于前台还是后台，默认为false     
-i, --interactive=false   打开STDIN，用于控制台交互    
-t, --tty=false            分配tty设备，该可以支持终端登录，默认为false    
-u, --user=&quot;&quot;              指定容器的用户    
-a, --attach=[]            登录容器（必须是以docker run -d启动的容器）  
-w, --workdir=&quot;&quot;           指定容器的工作目录   
-c, --cpu-shares=0        设置容器CPU权重，在CPU共享场景使用    
-e, --env=[]               指定环境变量，容器中可以使用该环境变量    
-m, --memory=&quot;&quot;            指定容器的内存上限    
-P, --publish-all=false    指定容器暴露的端口    
-p, --publish=[]           指定容器暴露的端口   
-h, --hostname=&quot;&quot;          指定容器的主机名    
-v, --volume=[]            给容器挂载存储卷，挂载到容器的某个目录    
--volumes-from=[]          给容器挂载其他容器上的卷，挂载到容器的某个目录  
--cap-add=[]               添加权限，权限清单详见：http://linux.die.net/man/7/capabilities    
--cap-drop=[]              删除权限，权限清单详见：http://linux.die.net/man/7/capabilities    
--cidfile=&quot;&quot;               运行容器后，在指定文件中写入容器PID值，一种典型的监控系统用法    
--cpuset=&quot;&quot;                设置容器可以使用哪些CPU，此参数可以用来容器独占CPU    
--device=[]                添加主机设备给容器，相当于设备直通    
--dns=[]                   指定容器的dns服务器    
--dns-search=[]            指定容器的dns搜索域名，写入到容器的/etc/resolv.conf文件    
--entrypoint=&quot;&quot;            覆盖image的入口点    
--env-file=[]              指定环境变量文件，文件格式为每行一个环境变量    
--expose=[]                指定容器暴露的端口，即修改镜像的暴露端口    
--link=[]                  指定容器间的关联，使用其他容器的IP、env等信息    
--lxc-conf=[]              指定容器的配置文件，只有在指定--exec-driver=lxc时使用    
--name=&quot;&quot;                  指定容器名字，后续可以通过名字进行容器管理，links特性需要使用名字    
--net=&quot;bridge&quot;             容器网络设置:  
                              bridge 使用docker daemon指定的网桥       
                              host    //容器使用主机的网络    
                              container:NAME_or_ID  &gt;//使用其他容器的网路，共享IP和PORT等网络资源    
                              none 容器使用自己的网络（类似--net=bridge），但是不进行配置   
--privileged=false         指定容器是否为特权容器，特权容器拥有所有的capabilities    
--restart=&quot;no&quot;             指定容器停止后的重启策略:  
                              no：容器退出时不重启    
                              on-failure：容器故障退出（返回值非零）时重启   
                              always：容器退出时总是重启    
--rm=false                 指定容器停止后自动删除容器(不支持以docker run -d启动的容器)    
--sig-proxy=true           设置由代理接受并处理信号，但是SIGCHLD、SIGSTOP和SIGKILL不能被代理    
</code></pre>
<h4 id="实例">实例</h4>
<p>使用docker镜像nginx:latest以后台模式启动一个容器,并将容器命名为mynginx</p>
<pre><code class="language-bash">docker run --name mynginx -d nginx:latest  
</code></pre>
<p>使用镜像nginx:latest以后台模式启动一个容器,并将容器的80端口映射到主机随机端口</p>
<pre><code class="language-bash">docker run -P -d nginx:latest    
</code></pre>
<p>使用镜像nginx:latest以后台模式启动一个容器,将容器的80端口映射到主机的80端口,主机的目录/data映射到容器的/data</p>
<pre><code class="language-bash">docker run -p 80:80 -v /data:/data -d nginx:latest     
</code></pre>
<p>使用镜像nginx:latest以交互模式启动一个容器,在容器内执行/bin/bash命令</p>
<pre><code class="language-bash">docker run -it nginx:latest /bin/bash    
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[egg.js跨域问题]]></title>
        <id>https://just4city.github.io/post/eggjs-kua-yu-wen-ti</id>
        <link href="https://just4city.github.io/post/eggjs-kua-yu-wen-ti">
        </link>
        <updated>2019-11-18T14:21:02.000Z</updated>
        <summary type="html"><![CDATA[<p>前后端分离下,egg如何设置跨域</p>
]]></summary>
        <content type="html"><![CDATA[<p>前后端分离下,egg如何设置跨域</p>
<!-- more -->
<p>不设置白名单，直接在egg跨域插件配置的origin里面指定访问域名并开启认证模式</p>
<pre><code class="language-javascript">config.cors = {
    origin:'http://ip:port',
    credentials: true,
    allowMethods: 'GET,HEAD,PUT,POST,DELETE,PATCH'
  };

</code></pre>
<p><a href="https://github.com/eggjs/egg/issues/725">https://github.com/eggjs/egg/issues/725</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[添加项目到【已存在的】Git仓库]]></title>
        <id>https://just4city.github.io/post/tian-jia-xiang-mu-dao-yi-cun-zai-de-git-cang-ku</id>
        <link href="https://just4city.github.io/post/tian-jia-xiang-mu-dao-yi-cun-zai-de-git-cang-ku">
        </link>
        <updated>2019-11-18T07:26:39.000Z</updated>
        <content type="html"><![CDATA[<h4 id="新的仓库">新的仓库</h4>
<pre><code class="language-bash">git init
git add README.md
git commit -m &quot;first commit&quot;
git remote add origin git@github.com:fhefh2018/hackintosh_efi_site.git
git push -u origin master
</code></pre>
<h4 id="已存在的仓库">已存在的仓库</h4>
<pre><code class="language-bash">git remote add origin git@github.com:fhefh2018/hackintosh_efi_site.git
git push -u origin master
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[CenterOS安装Node]]></title>
        <id>https://just4city.github.io/post/centeros-an-zhuang-node</id>
        <link href="https://just4city.github.io/post/centeros-an-zhuang-node">
        </link>
        <updated>2019-11-15T07:22:42.000Z</updated>
        <content type="html"><![CDATA[<h4 id="安装nvm">安装NVM</h4>
<pre><code class="language-bash">curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.35.1/install.sh | bash

wget -qO- https://raw.githubusercontent.com/nvm-sh/nvm/v0.35.1/install.sh | bash

</code></pre>
<h4 id="配置环境变量~bash_profile-~zshrc-~profile-~bashrc">配置环境变量:<code>~/.bash_profile</code>、<code>~/.zshrc</code>、<code>~/.profile</code>、<code>~/.bashrc</code></h4>
<pre><code class="language-bash">export NVM_DIR=&quot;$([ -z &quot;${XDG_CONFIG_HOME-}&quot; ] &amp;&amp; printf %s &quot;${HOME}/.nvm&quot; || printf %s &quot;${XDG_CONFIG_HOME}/nvm&quot;)&quot;
[ -s &quot;$NVM_DIR/nvm.sh&quot; ] &amp;&amp; \. &quot;$NVM_DIR/nvm.sh&quot;
</code></pre>
<h4 id="安装node">安装Node</h4>
<pre><code class="language-bash">nvm install node
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[甲骨文云Oracle Cloud/亚马逊AWS等云服务器开启root用户登录]]></title>
        <id>https://just4city.github.io/post/jia-gu-wen-yun-oracle-cloudya-ma-xun-aws-deng-yun-fu-wu-qi-kai-qi-root-yong-hu-deng-lu</id>
        <link href="https://just4city.github.io/post/jia-gu-wen-yun-oracle-cloudya-ma-xun-aws-deng-yun-fu-wu-qi-kai-qi-root-yong-hu-deng-lu">
        </link>
        <updated>2019-11-14T02:50:28.000Z</updated>
        <content type="html"><![CDATA[<p>一些云服务商默认禁止了root用户登录, 现在分享一下开启root用户登录的方法.<br>
以oracle cloud的centos系统为例:</p>
<pre><code class="language-bash">ssh opc@你的ip地址
</code></pre>
<p>登录服务器</p>
<pre><code class="language-bash">sudo -i
</code></pre>
<p>切换root用户</p>
<pre><code class="language-bash">#把ssh-rsa之前的都删除
vi .ssh/authorized_keys
</code></pre>
<p>编辑ssh配置文件, 找到PermitRootLogin, 把前面的#去掉</p>
<pre><code class="language-bash">vi /etc/ssh/sshd_config
PermitRootLogin yes
</code></pre>
<p>重启ssh服务</p>
<pre><code class="language-bash">service sshd restart
</code></pre>
<p>更改密码</p>
<pre><code class="language-bash">echo root:your_password |sudo chpasswd root
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[解决oh-my-zsh docker不自动补全问题]]></title>
        <id>https://just4city.github.io/post/jie-jue-oh-my-zsh-docker-bu-zi-dong-bu-quan-wen-ti</id>
        <link href="https://just4city.github.io/post/jie-jue-oh-my-zsh-docker-bu-zi-dong-bu-quan-wen-ti">
        </link>
        <updated>2019-11-11T02:39:17.000Z</updated>
        <content type="html"><![CDATA[<p>问题，如图所示：<br>
<img src="https://cdn.jsdelivr.net/gh/just4picbed/oss@master//20191111104208-kNMNmH.jpg" alt=""></p>
<p>解决办法：</p>
<pre><code class="language-bash">rm ~/.zcompdump*
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ Docker中删除images报错]]></title>
        <id>https://just4city.github.io/post/docker-zhong-shan-chu-images-bao-cuo</id>
        <link href="https://just4city.github.io/post/docker-zhong-shan-chu-images-bao-cuo">
        </link>
        <updated>2019-11-10T06:59:00.000Z</updated>
        <content type="html"><![CDATA[<pre><code class="language-bash">[root@hadoop14 ~]# docker rmi ubuntu:v2
Failed to remove image (ubuntu:v2): Error response from daemon: conflict: unable to remove repository reference &quot;ubuntu:v2&quot; (must force) - container d63a819c3eaf is using its referenced image a8edd5cf3708
</code></pre>
<p>原因：<code>Docker无法删除images，由于是依赖container</code><br>
步骤：</p>
<pre><code>- docker rm b23dd9de7382(删除依赖的container d63a819c3eaf)
- 可能有多个依赖，全部删除
</code></pre>
<p>停止所有的container，这样才能够删除其中的images：</p>
<pre><code class="language-bash">docker stop $(docker ps -a -q)
</code></pre>
<p>如果想要删除所有container的话再加一个指令：</p>
<pre><code class="language-bash">docker rm $(docker ps -a -q)
</code></pre>
<p>查看当前有些什么images</p>
<pre><code class="language-bash">docker images
</code></pre>
<p>删除images，通过image的id来指定删除谁</p>
<pre><code class="language-bash">docker rmi [IMAGE ID]
</code></pre>
<p>想要删除untagged images，也就是那些id为的image的话可以用</p>
<pre><code class="language-bash">docker rmi  $(docker images | grep &quot;^&lt;none&gt;&quot; | awk &quot;{print $3}&quot;)
</code></pre>
<p>要删除全部image的话</p>
<pre><code class="language-bash">docker rmi $(docker images -q)
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[新购买的VPS如何配置]]></title>
        <id>https://just4city.github.io/post/xin-gou-mai-de-vps-ru-he-pei-zhi</id>
        <link href="https://just4city.github.io/post/xin-gou-mai-de-vps-ru-he-pei-zhi">
        </link>
        <updated>2019-11-07T14:04:15.000Z</updated>
        <summary type="html"><![CDATA[<p>由于经常安装云服务器，再次记录下。</p>
]]></summary>
        <content type="html"><![CDATA[<p>由于经常安装云服务器，再次记录下。</p>
<!--more-->
<h2 id="安装相关包">安装相关包</h2>
<pre><code class="language-bash">yum install -y gcc
yum install -y openssl
yum install -y openssl-devel
yum install -y zlib-devel
yum install -y git
yum install -y unzip
</code></pre>
<h2 id="禁用密码登陆使用秘钥登陆">禁用密码登陆，使用秘钥登陆</h2>
<pre><code class="language-bash">vim /etc/ssh/sshd_config

# 是否让 sshd 去检查用户家目录或相关档案的权限数据，
# 这是为了担心使用者将某些重要档案的权限设错，可能会导致一些问题所致。
# 例如使用者的 ~.ssh/ 权限设错时，某些特殊情况下会不许用户登入
StrictModes no
# 是否允许用户自行使用成对的密钥系统进行登入行为，仅针对 version 2。
# 至于自制的公钥数据就放置于用户家目录下的 .ssh/authorized_keys 内
RSAAuthentication yes
PubkeyAuthentication yes
AuthorizedKeysFile      %h/.ssh/authorized_keys
#有了证书登录了，就禁用密码登录吧，安全要紧
PasswordAuthentication no

#重启服务

#ubuntu
/etc/init.d/ssh restart

#centos
service sshd restart

</code></pre>
<h2 id="升级vim8">升级VIM8</h2>
<pre><code class="language-bash">yum install ncurses-devel
wget https://github.com/vim/vim/archive/v8.0.1376.zip
unzip master.zip
cd vim-master
cd src/
./configure
make
sudo make install
vim

//配置增强版VIM
//安装
bash &lt;(curl -fsSL https://raw.githubusercontent.com/liuchengxu/space-vim/master/install.sh)
//卸载
bash &lt;(curl -fsSL https://raw.githubusercontent.com/liuchengxu/space-vim/master/uninstall.sh)

</code></pre>
<h2 id="安装oh-my-zsh">安装oh-my-zsh</h2>
<pre><code class="language-bash">//安装zsh
yum -y install zsh

//切换shell
chsh -s /bin/zsh

//安装oh my zsh
//curl
sh -c &quot;$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)&quot;
//wget 
sh -c &quot;$(wget https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh -O -)&quot;

//添加插件
git clone https://github.com/zsh-users/zsh-autosuggestions $ZSH_CUSTOM/plugins/zsh-autosuggestions

//vim .zshrc中找到plugins
//plugins=(zsh-autosuggestions)
</code></pre>
<h2 id="安装python3">安装Python3</h2>
<pre><code class="language-bash">wget https://www.python.org/ftp/python/3.6.1/Python-3.6.1.tgz
tar xzvf Python-3.6.1.tgz
</code></pre>
<p>修改Pyhton3安装配置 解决SSL模块无法使用问题</p>
<pre><code class="language-bash">vim Modules/Setup.dist 或
vim Modules/Setup
# Socket module helper for socket(2)
_socket socketmodule.c timemodule.c
# Socket module helper for SSL support; you must comment out the other
# socket line above, and possibly edit the SSL variable:
#SSL=/usr/local/ssl
_ssl _ssl.c \
-DUSE_SSL -I$(SSL)/include -I$(SSL)/include/openssl \
-L$(SSL)/lib -lssl -lcrypto
</code></pre>
<h5 id="安装python3-2">安装Python3</h5>
<pre><code class="language-bash">cd Python-3.6.1
mkdir /usr/local/python3.6
./configure --prefix=/usr/local/python3.6
make
make install
</code></pre>
<h5 id="替换原有的python链接">替换原有的Python链接</h5>
<pre><code class="language-bash">mv /usr/bin/python /usr/bin/python_bak
ln -s /usr/local/python3.1/bin/python3.1  /usr/bin/python 
注意要修改yum文件，yum依赖系统的python
vim /usr/bin/yum
打开文件后，将/usr/bin/python修改成/usr/bin/python_bak即可

</code></pre>
<h2 id="安装ufw">安装ufw</h2>
<pre><code>//ubuntu
apt-get install ufw -y 

//debian
apt-get install ufw -y

//center os
yum install epel-release -y
yum install --enablerepo=&quot;epel&quot; ufw -y

</code></pre>
<h2 id="ufw相关配置">ufw相关配置</h2>
<p><a href="https://linuxconfig.org/how-to-install-and-use-ufw-firewall-on-linux">https://linuxconfig.org/how-to-install-and-use-ufw-firewall-on-linux</a></p>
<p><a href="http://notes.maxwi.com/2017/01/19/linux-command-tools-ufw">http://notes.maxwi.com/2017/01/19/linux-command-tools-ufw</a></p>
<pre><code class="language-bash">//默认配置
ufw default deny incoming
ufw default allow outgoing
</code></pre>
<h2 id="cloudflare-ufw配置">cloudflare ufw配置</h2>
<p><code>cloudflare-ufw.sh</code>, <a href="https://github.com/Paul-Reed/cloudflare-ufw/blob/master/cloudflare-ufw.sh">参考链接</a>:</p>
<pre><code class="language-bash">#!/bin/sh

DIR=&quot;$(dirname $(readlink -f $0))&quot;
cd $DIR
wget https://www.cloudflare.com/ips-v4 -O ips-v4.tmp
wget https://www.cloudflare.com/ips-v6 -O ips-v6.tmp
mv ips-v4.tmp ips-v4
mv ips-v6.tmp ips-v6

for cfip in `cat ips-v4`; do ufw allow from $cfip; done
for cfip in `cat ips-v6`; do ufw allow from $cfip; done

ufw reload &gt; /dev/null

# OTHER EXAMPLE RULES
# Examples to retrict to port 80
#for cfip in `cat ips-v4`; do ufw allow from $cfip to any port 80 proto tcp; done
#for cfip in `cat ips-v6`; do ufw allow from $cfip to any port 80 proto tcp; done

# Examples to restrict to port 443
#for cfip in `cat ips-v4`; do ufw allow from $cfip to any port 443 proto tcp; done
#for cfip in `cat ips-v6`; do ufw allow from $cfip to any port 443 proto tcp; done

</code></pre>
<p>配置运行：</p>
<pre><code class="language-bash">sudo crontab -e

0 0 * * 1 /opt/cloudflare/cloudflare-ufw.sh &gt; /dev/null 2&gt;&amp;1
</code></pre>
]]></content>
    </entry>
</feed>