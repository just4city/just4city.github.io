<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://just4city.github.io</id>
    <title>Gridea</title>
    <updated>2019-11-24T15:22:03.875Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://just4city.github.io"/>
    <link rel="self" href="https://just4city.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://just4city.github.io/images/avatar.png</logo>
    <icon>https://just4city.github.io/favicon.ico</icon>
    <rights>All rights reserved 2019, Gridea</rights>
    <entry>
        <title type="html"><![CDATA[Nginx解决vue router的history模式下，页面刷新404]]></title>
        <id>https://just4city.github.io/post/nginx-jie-jue-vue-router-de-history-mo-shi-xia-ye-mian-shua-xin-404</id>
        <link href="https://just4city.github.io/post/nginx-jie-jue-vue-router-de-history-mo-shi-xia-ye-mian-shua-xin-404">
        </link>
        <updated>2019-11-24T07:31:27.000Z</updated>
        <summary type="html"><![CDATA[<p>在日常开发中，我们使用到vue一般会有两种路由模式，一种是hash一种是history。相较于hash又长又臭的路由地址，相信大多数人更加喜欢history模式清爽的路由格式。但同样的，history模式也存在着一些问题。</p>
]]></summary>
        <content type="html"><![CDATA[<p>在日常开发中，我们使用到vue一般会有两种路由模式，一种是hash一种是history。相较于hash又长又臭的路由地址，相信大多数人更加喜欢history模式清爽的路由格式。但同样的，history模式也存在着一些问题。</p>
<!-- more -->
<p>因为我们的应用是个单页客户端应用，如果后台没有正确的配置，当用户在浏览器直接访问http://xxx.com/user/id就会返回 404，这就不好看了。官方给出了几种解决方式如下：</p>
<pre><code class="language-bash">//Apache
&lt;IfModule mod_rewrite.c&gt;
  RewriteEngine On
  RewriteBase /
  RewriteRule ^index\.html$ - [L]
  RewriteCond %{REQUEST_FILENAME} !-f
  RewriteCond %{REQUEST_FILENAME} !-d
  RewriteRule . /index.html [L]
&lt;/IfModule&gt;

//Nginx
location / {
  try_files $uri $uri/ /index.html;
}

//Tomcat
&lt;error-page&gt;    
    &lt;error-code&gt;404&lt;/error-code&gt;    
    &lt;location&gt;/&lt;/location&gt;    
&lt;/error-page&gt; 
</code></pre>
<p><a href="https://ethan.pub/?p=897">https://ethan.pub/?p=897</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Vue:axios减少重复请求数据 keep-alive]]></title>
        <id>https://just4city.github.io/post/vueaxios-jian-shao-chong-fu-qing-qiu-shu-ju-keep-alive</id>
        <link href="https://just4city.github.io/post/vueaxios-jian-shao-chong-fu-qing-qiu-shu-ju-keep-alive">
        </link>
        <updated>2019-11-23T02:46:06.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://www.jianshu.com/p/03b9474c2dc1">https://www.jianshu.com/p/03b9474c2dc1</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[vue-cli3.0项目使用proxy跨域]]></title>
        <id>https://just4city.github.io/post/vue-cli30-xiang-mu-shi-yong-proxy-kua-yu</id>
        <link href="https://just4city.github.io/post/vue-cli30-xiang-mu-shi-yong-proxy-kua-yu">
        </link>
        <updated>2019-11-20T06:32:07.000Z</updated>
        <content type="html"><![CDATA[<p>通过vue-cli3.x版本构建的项目使用proxy和以前的项目不同，而且3.x版本构建的时候可以选用typescript了。下面记录一下如何使用proxy跨域。<br>
首先在根目录创建vue.config.js文件，这个配置文件在运行项目的时候自动加载。</p>
<pre><code class="language-javascript">// vue.config.js
module.exports = {
  devServer: {
    proxy: {
      '/api': {
        target: 'http://xxxx/device/', //对应自己的接口
        changeOrigin: true,
        ws: true,
        pathRewrite: {
          '^/api': ''
        }
      }
    }
  }
}

</code></pre>
<p>请求:</p>
<pre><code class="language-javascript">axios.get('/api/getDataPoint').then(res =&gt; {
  console.log(res)
})
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[nginx 同一个域名下部署多个工程]]></title>
        <id>https://just4city.github.io/post/nginx-tong-yi-ge-yu-ming-xia-bu-shu-duo-ge-gong-cheng</id>
        <link href="https://just4city.github.io/post/nginx-tong-yi-ge-yu-ming-xia-bu-shu-duo-ge-gong-cheng">
        </link>
        <updated>2019-11-19T14:26:24.000Z</updated>
        <content type="html"><![CDATA[<p>https://blog.csdn.net/chenhuaping007/article/details/79997901</p>
<p>https://juejin.im/post/5cfe23b3e51d4556f76e8073</p>
<p>https://juejin.im/post/5d7b72b7e51d453b386a63bc</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Docker run 命令参数及使用]]></title>
        <id>https://just4city.github.io/post/docker-run-ming-ling-can-shu-ji-shi-yong</id>
        <link href="https://just4city.github.io/post/docker-run-ming-ling-can-shu-ji-shi-yong">
        </link>
        <updated>2019-11-19T09:08:44.000Z</updated>
        <content type="html"><![CDATA[<h4 id="docker-run-创建一个新的容器并运行一个命令">Docker run ：创建一个新的容器并运行一个命令</h4>
<pre><code class="language-bash">docker run [OPTIONS] IMAGE [COMMAND] [ARG...]  
</code></pre>
<p>OPTIONS说明：</p>
<pre><code class="language-bash">Usage: docker run [OPTIONS] IMAGE [COMMAND] [ARG...]    

-d, --detach=false         指定容器运行于前台还是后台，默认为false     
-i, --interactive=false   打开STDIN，用于控制台交互    
-t, --tty=false            分配tty设备，该可以支持终端登录，默认为false    
-u, --user=&quot;&quot;              指定容器的用户    
-a, --attach=[]            登录容器（必须是以docker run -d启动的容器）  
-w, --workdir=&quot;&quot;           指定容器的工作目录   
-c, --cpu-shares=0        设置容器CPU权重，在CPU共享场景使用    
-e, --env=[]               指定环境变量，容器中可以使用该环境变量    
-m, --memory=&quot;&quot;            指定容器的内存上限    
-P, --publish-all=false    指定容器暴露的端口    
-p, --publish=[]           指定容器暴露的端口   
-h, --hostname=&quot;&quot;          指定容器的主机名    
-v, --volume=[]            给容器挂载存储卷，挂载到容器的某个目录    
--volumes-from=[]          给容器挂载其他容器上的卷，挂载到容器的某个目录  
--cap-add=[]               添加权限，权限清单详见：http://linux.die.net/man/7/capabilities    
--cap-drop=[]              删除权限，权限清单详见：http://linux.die.net/man/7/capabilities    
--cidfile=&quot;&quot;               运行容器后，在指定文件中写入容器PID值，一种典型的监控系统用法    
--cpuset=&quot;&quot;                设置容器可以使用哪些CPU，此参数可以用来容器独占CPU    
--device=[]                添加主机设备给容器，相当于设备直通    
--dns=[]                   指定容器的dns服务器    
--dns-search=[]            指定容器的dns搜索域名，写入到容器的/etc/resolv.conf文件    
--entrypoint=&quot;&quot;            覆盖image的入口点    
--env-file=[]              指定环境变量文件，文件格式为每行一个环境变量    
--expose=[]                指定容器暴露的端口，即修改镜像的暴露端口    
--link=[]                  指定容器间的关联，使用其他容器的IP、env等信息    
--lxc-conf=[]              指定容器的配置文件，只有在指定--exec-driver=lxc时使用    
--name=&quot;&quot;                  指定容器名字，后续可以通过名字进行容器管理，links特性需要使用名字    
--net=&quot;bridge&quot;             容器网络设置:  
                              bridge 使用docker daemon指定的网桥       
                              host    //容器使用主机的网络    
                              container:NAME_or_ID  &gt;//使用其他容器的网路，共享IP和PORT等网络资源    
                              none 容器使用自己的网络（类似--net=bridge），但是不进行配置   
--privileged=false         指定容器是否为特权容器，特权容器拥有所有的capabilities    
--restart=&quot;no&quot;             指定容器停止后的重启策略:  
                              no：容器退出时不重启    
                              on-failure：容器故障退出（返回值非零）时重启   
                              always：容器退出时总是重启    
--rm=false                 指定容器停止后自动删除容器(不支持以docker run -d启动的容器)    
--sig-proxy=true           设置由代理接受并处理信号，但是SIGCHLD、SIGSTOP和SIGKILL不能被代理    
</code></pre>
<h4 id="实例">实例</h4>
<p>使用docker镜像nginx:latest以后台模式启动一个容器,并将容器命名为mynginx</p>
<pre><code class="language-bash">docker run --name mynginx -d nginx:latest  
</code></pre>
<p>使用镜像nginx:latest以后台模式启动一个容器,并将容器的80端口映射到主机随机端口</p>
<pre><code class="language-bash">docker run -P -d nginx:latest    
</code></pre>
<p>使用镜像nginx:latest以后台模式启动一个容器,将容器的80端口映射到主机的80端口,主机的目录/data映射到容器的/data</p>
<pre><code class="language-bash">docker run -p 80:80 -v /data:/data -d nginx:latest     
</code></pre>
<p>使用镜像nginx:latest以交互模式启动一个容器,在容器内执行/bin/bash命令</p>
<pre><code class="language-bash">docker run -it nginx:latest /bin/bash    
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[egg.js跨域问题]]></title>
        <id>https://just4city.github.io/post/eggjs-kua-yu-wen-ti</id>
        <link href="https://just4city.github.io/post/eggjs-kua-yu-wen-ti">
        </link>
        <updated>2019-11-18T14:21:02.000Z</updated>
        <summary type="html"><![CDATA[<p>前后端分离下,egg如何设置跨域</p>
]]></summary>
        <content type="html"><![CDATA[<p>前后端分离下,egg如何设置跨域</p>
<!-- more -->
<p>不设置白名单，直接在egg跨域插件配置的origin里面指定访问域名并开启认证模式</p>
<pre><code class="language-javascript">config.cors = {
    origin:'http://ip:port',
    credentials: true,
    allowMethods: 'GET,HEAD,PUT,POST,DELETE,PATCH'
  };

</code></pre>
<p><a href="https://github.com/eggjs/egg/issues/725">https://github.com/eggjs/egg/issues/725</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[添加项目到【已存在的】Git仓库]]></title>
        <id>https://just4city.github.io/post/tian-jia-xiang-mu-dao-yi-cun-zai-de-git-cang-ku</id>
        <link href="https://just4city.github.io/post/tian-jia-xiang-mu-dao-yi-cun-zai-de-git-cang-ku">
        </link>
        <updated>2019-11-18T07:26:39.000Z</updated>
        <content type="html"><![CDATA[<h4 id="新的仓库">新的仓库</h4>
<pre><code class="language-bash">git init
git add README.md
git commit -m &quot;first commit&quot;
git remote add origin git@github.com:fhefh2018/hackintosh_efi_site.git
git push -u origin master
</code></pre>
<h4 id="已存在的仓库">已存在的仓库</h4>
<pre><code class="language-bash">git remote add origin git@github.com:fhefh2018/hackintosh_efi_site.git
git push -u origin master
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[CenterOS安装Node]]></title>
        <id>https://just4city.github.io/post/centeros-an-zhuang-node</id>
        <link href="https://just4city.github.io/post/centeros-an-zhuang-node">
        </link>
        <updated>2019-11-15T07:22:42.000Z</updated>
        <content type="html"><![CDATA[<h4 id="安装nvm">安装NVM</h4>
<pre><code class="language-bash">curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.35.1/install.sh | bash

wget -qO- https://raw.githubusercontent.com/nvm-sh/nvm/v0.35.1/install.sh | bash

</code></pre>
<h4 id="配置环境变量~bash_profile-~zshrc-~profile-~bashrc">配置环境变量:<code>~/.bash_profile</code>、<code>~/.zshrc</code>、<code>~/.profile</code>、<code>~/.bashrc</code></h4>
<pre><code class="language-bash">export NVM_DIR=&quot;$([ -z &quot;${XDG_CONFIG_HOME-}&quot; ] &amp;&amp; printf %s &quot;${HOME}/.nvm&quot; || printf %s &quot;${XDG_CONFIG_HOME}/nvm&quot;)&quot;
[ -s &quot;$NVM_DIR/nvm.sh&quot; ] &amp;&amp; \. &quot;$NVM_DIR/nvm.sh&quot;
</code></pre>
<h4 id="安装node">安装Node</h4>
<pre><code class="language-bash">nvm install node
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[甲骨文云Oracle Cloud/亚马逊AWS等云服务器开启root用户登录]]></title>
        <id>https://just4city.github.io/post/jia-gu-wen-yun-oracle-cloudya-ma-xun-aws-deng-yun-fu-wu-qi-kai-qi-root-yong-hu-deng-lu</id>
        <link href="https://just4city.github.io/post/jia-gu-wen-yun-oracle-cloudya-ma-xun-aws-deng-yun-fu-wu-qi-kai-qi-root-yong-hu-deng-lu">
        </link>
        <updated>2019-11-14T02:50:28.000Z</updated>
        <content type="html"><![CDATA[<p>一些云服务商默认禁止了root用户登录, 现在分享一下开启root用户登录的方法.<br>
以oracle cloud的centos系统为例:</p>
<pre><code class="language-bash">ssh opc@你的ip地址
</code></pre>
<p>登录服务器</p>
<pre><code class="language-bash">sudo -i
</code></pre>
<p>切换root用户</p>
<pre><code class="language-bash">#把ssh-rsa之前的都删除
vi .ssh/authorized_keys
</code></pre>
<p>编辑ssh配置文件, 找到PermitRootLogin, 把前面的#去掉</p>
<pre><code class="language-bash">vi /etc/ssh/sshd_config
PermitRootLogin yes
</code></pre>
<p>重启ssh服务</p>
<pre><code class="language-bash">service sshd restart
</code></pre>
<p>更改密码</p>
<pre><code class="language-bash">echo root:your_password |sudo chpasswd root
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[解决oh-my-zsh docker不自动补全问题]]></title>
        <id>https://just4city.github.io/post/jie-jue-oh-my-zsh-docker-bu-zi-dong-bu-quan-wen-ti</id>
        <link href="https://just4city.github.io/post/jie-jue-oh-my-zsh-docker-bu-zi-dong-bu-quan-wen-ti">
        </link>
        <updated>2019-11-11T02:39:17.000Z</updated>
        <content type="html"><![CDATA[<p>问题，如图所示：<br>
<img src="https://cdn.jsdelivr.net/gh/just4picbed/oss@master//20191111104208-kNMNmH.jpg" alt=""></p>
<p>解决办法：</p>
<pre><code class="language-bash">rm ~/.zcompdump*
</code></pre>
]]></content>
    </entry>
</feed>