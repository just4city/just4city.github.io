<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://just4city.github.io</id>
    <title>Gridea</title>
    <updated>2019-12-03T07:21:52.857Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://just4city.github.io"/>
    <link rel="self" href="https://just4city.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://just4city.github.io/images/avatar.png</logo>
    <icon>https://just4city.github.io/favicon.ico</icon>
    <rights>All rights reserved 2019, Gridea</rights>
    <entry>
        <title type="html"><![CDATA[手写JS函数的call、apply、bind实现]]></title>
        <id>https://just4city.github.io/post/shou-xie-js-han-shu-de-callapplybind-shi-xian</id>
        <link href="https://just4city.github.io/post/shou-xie-js-han-shu-de-callapplybind-shi-xian">
        </link>
        <updated>2019-12-03T07:18:30.000Z</updated>
        <content type="html"><![CDATA[<h3 id="call">call</h3>
<pre><code class="language-javascript">/**
 * 自定义call实现
 * @param context   上下文this对象
 * @param args      动态参数
 */
Function.prototype.ownCall = function(context, ...args) {
  context = (typeof context === 'object' ? context : window)
  // 防止覆盖掉原有属性
  const key = Symbol()
  // 这里的this为需要执行的方法
  context[key] = this
  // 方法执行
  const result = context[key](...args)
  delete context[key]
  return result
}

// 验证样例
function fun(arg1, arg2) {
  console.log(this.name)
  console.log(arg1 + arg2)
}
const _this = { name: 'YIYING' }
// 接受的是一个参数列表;方法立即执行
fun.ownCall(_this, 1, 2)

// 输出：
YIYING
3

</code></pre>
<h3 id="apply">apply</h3>
<pre><code class="language-javascript">/**
 * 自定义Apply实现
 * @param context   上下文this对象
 * @param args      参数数组
 */
Function.prototype.ownApply = function(context, args) {
  context = (typeof context === 'object' ? context : window)
  // 防止覆盖掉原有属性
  const key = Symbol()
  // 这里的this为需要执行的方法
  context[key] = this
  // 方法执行
  const result = context[key](...args)
  delete context[key]
  return result
}

// 验证样例
function fun(arg1, arg2) {
  console.log(this.name)
  console.log(arg1 + arg2)
}
const _this = { name: 'YIYING' }
// 参数为数组;方法立即执行
fun.ownApply(_this, [1, 2])

// 输出：
YIYING
3
</code></pre>
<h3 id="bind">bind</h3>
<pre><code class="language-javascript">/**
 * 自定义bind实现
 * @param context     上下文
 * @returns {Function}
 */
Function.prototype.ownBind = function(context) {
  context = (typeof context === 'object' ? context : window)
  return (...args)=&gt;{
    this.call(context, ...args)
  }
}

// 验证样例
function fun(arg1, arg2) {
  console.log(this.name)
  console.log(arg1 + arg2)
}
const _this = { name: 'YIYING' }
// 只变更fun中的this指向，返回新function对象
const newFun = fun.ownBind(_this)
newFun(1, 2)

// 输出：
YIYING
3
</code></pre>
<p>参考:<br>
<a href="https://juejin.im/post/5de3881ee51d4501b9561ada?utm_source=gold_browser_extension">手写JS函数的call、apply、bind实现</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[vue.config.js别名配置]]></title>
        <id>https://just4city.github.io/post/vueconfigjs-bie-ming-pei-zhi</id>
        <link href="https://just4city.github.io/post/vueconfigjs-bie-ming-pei-zhi">
        </link>
        <updated>2019-12-02T13:15:26.000Z</updated>
        <content type="html"><![CDATA[<h3 id="配置别名alias">配置别名alias</h3>
<pre><code class="language-javascript">chainWebpack: config =&gt; {
    // 别名
    config.resolve.alias
        .set('@', resolve('src'))
        .set('@assets',resolve('src/assets'))
        .set('@images',resolve('src/assets/images'));
</code></pre>
<h3 id="在style标签中使用background引用图片可正确解析路径">在<code>style</code>标签中，使用<code>background</code>引用图片可正确解析路径</h3>
<pre><code class="language-css">.footer .button_wrap .icon1 {
    background: url(&quot;~@images/main_ic_index_off.png&quot;) no-repeat center center;
        background-size: 100% 100%;
}
</code></pre>
<h3 id="在-webstorm-中配置能够识别-vue-cli-3-创建的项目的别名">在 WebStorm 中，配置能够识别 Vue CLI 3 创建的项目的别名@</h3>
<p>方法1：项目根目录创建一个文件 alias.config.js：</p>
<pre><code class="language-javascript">const resolve = dir =&gt; require('path').join(__dirname, dir);

module.exports = {
    resolve: {
        alias: {
            '@': resolve('src'),
            '@assets': resolve('src/assets'),
            '@images': resolve('src/assets/images')
        }
    }
};
</code></pre>
<p>方法2：直接引入文件<code>项目目录\node_modules\@vue\cli-service\webpack.config.js</code>即可</p>
<p>两个方法都需要在Webstrom中进行设置</p>
<figure data-type="image" tabindex="1"><img src="https://i.imgur.com/KGAY5NO.png" alt=""></figure>
<p>参考：<br>
<a href="https://juejin.im/post/5c9477ad6fb9a070ce31b050">在 WebStorm 中，配置能够识别 Vue CLI 3 创建的项目的别名 alias @</a><br>
<a href="https://www.cnblogs.com/CyLee/p/8438824.html">webpack 使用别名（resolve.alias）解决scss @import相对路径导致的问题</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JavaScript中的同步和异步]]></title>
        <id>https://just4city.github.io/post/javascript-zhong-de-tong-bu-he-yi-bu</id>
        <link href="https://just4city.github.io/post/javascript-zhong-de-tong-bu-he-yi-bu">
        </link>
        <updated>2019-12-01T05:21:19.000Z</updated>
        <content type="html"><![CDATA[<p>你应该知道，javascript语言是一门“单线程”的语言，不像java语言，类继承Thread再来个thread.start就可以开辟一个线程，所以，javascript就像一条流水线，仅仅是一条流水线而已，要么加工，要么包装，不能同时进行多个任务和流程。</p>
<p>那么这里说的同步和异步到底是什么呢？如果你真的不懂，我希望你认真读完这篇文章。其实我个人觉得js官方的文档在使用两个词的时候并不准确，包括很多其他词汇，都只是听起来高深，但实际应用好像跟这些词没半毛钱关系。例如“事件委托”这个词，不知道的人乍一看谁又能说出“事件委托”是什么意思？委托什么事件？怎么个委托，我看不如干脆就叫“事件在外层元素中的捕获”，虽然长一点，一下就能看懂。</p>
<p>回归正轨，“同步”——一下就让人想到“一起”这个词；“异步”呢，从字面来讲，好像是在不同的（异）的ways上do something，那首先想到的词可能是“一边...一边...”,比如‘小明一边吃雪糕一边写作业’，这完全没毛病，雪糕吃完了，作业也写完了，这就是异步？那就大错特错了！</p>
<p>其实同步和异步，无论如何，做事情的时候都是只有一条流水线（单线程），同步和异步的差别就在于<code>这条流水线上各个流程的执行顺序不同</code>。</p>
<p>最基础的异步是setTimeout和setInterval函数，很常见，但是很少人有人知道其实这就是异步，因为它们可以控制js的执行顺序。我们也可以简单地理解为：可以改变程序正常执行顺序的操作就可以看成是异步操作。如下代码：</p>
<pre><code class="language-javascript">console.log( &quot;1&quot; );
setTimeout(function() {
    console.log( &quot;2&quot; )
}, 0 );
setTimeout(function() {
    console.log( &quot;3&quot; )
}, 0 );
setTimeout(function() {
    console.log( &quot;4&quot; )
}, 0 );
console.log( &quot;5&quot; );
//显示结果
1
5
2
3
4
</code></pre>
<p>可见，尽管我们设置了setTimeout（function，time）中的等待时间为0，结果其中的function还是后执行。</p>
<p>火狐浏览器的api文档有这样一句话：Because even though setTimeout was called with a delay of zero, it's placed on a queue and scheduled to run at the next opportunity, not immediately. Currently executing code must complete before functions on the queue are executed, the resulting execution order may not be as expected.</p>
<p>意思就是：尽管setTimeout的time延迟时间为0，其中的function也会被放入一个队列中，等待下一个机会执行，当前的代码（指不需要加入队列中的程序）必须在该队列的程序完成之前完成，因此结果可能不与预期结果相同。</p>
<p>这里说到了一个“队列”（即任务队列），该队列放的是什么呢，放的就是setTimeout中的function，这些function依次加入该队列，即该队列中所有function中的程序将会在该队列以外的所有代码执行完毕之后再以此执行，这是为什么呢？因为在执行程序的时候，浏览器会默认setTimeout以及ajax请求这一类的方法都是耗时程序（尽管可能不耗时），将其加入一个队列中，该队列是一个存储耗时程序的队列，在所有不耗时程序执行过后，再来依次执行该队列中的程序。</p>
<p>又回到了最初的起点——javascript是单线程。单线程就意味着，所有任务需要排队，前一个任务结束，才会执行后一个任务。如果前一个任务耗时很长，后一个任务就不得不一直等着。于是就有一个概念——任务队列。如果排队是因为计算量大，CPU忙不过来，倒也算了，但是很多时候CPU是闲着的，因为IO设备（输入输出设备）很慢（比如Ajax操作从网络读取数据），不得不等着结果出来，再往下执行。于是JavaScript语言的设计者意识到，这时主线程完全可以不管IO设备，挂起处于等待中的任务，先运行排在后面的任务。等到IO设备返回了结果，再回过头，把挂起的任务继续执行下去。</p>
<p><code>于是，所有任务可以分成两种，一种是同步任务（synchronous），另一种是异步任务（asynchronous）。同步任务指的是，在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务；异步任务指的是，不进入主线程、而进入&quot;任务队列&quot;（task queue）的任务，只有等主线程任务执行完毕，&quot;任务队列&quot;开始通知主线程，请求执行任务，该任务才会进入主线程执行。</code></p>
<p>只要主线程空了，就会去读取&quot;任务队列&quot;，这就是JavaScript的运行机制。这个过程会不断重复。</p>
<p>&quot;任务队列&quot;是一个事件的队列（也可以理解成消息的队列），IO设备完成一项任务，就在&quot;任务队列&quot;中添加一个事件，表示相关的异步任务可以进入&quot;执行栈&quot;了。主线程读取&quot;任务队列&quot;，就是读取里面有哪些事件。<br>
&quot;任务队列&quot;中的事件，除了IO设备的事件以外，还包括一些用户产生的事件（比如鼠标点击、页面滚动等等），比如$(selectot).click(function)，这些都是相对耗时的操作。只要指定过这些事件的回调函数，这些事件发生时就会进入&quot;任务队列&quot;，等待主线程读取。</p>
<p>所谓&quot;回调函数&quot;（callback），就是那些会被主线程挂起来的代码，前面说的点击事件$(selectot).click(function)中的function就是一个回调函数。异步任务必须指定回调函数，当主线程开始执行异步任务，就是执行对应的回调函数。例如ajax的success，complete，error也都指定了各自的回调函数，这些函数就会加入“任务队列”中，等待执行。</p>
<p>来源:<br>
<a href="https://blog.csdn.net/qq_22855325/article/details/72958345">https://blog.csdn.net/qq_22855325/article/details/72958345</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Vue-cli 3.0 怎么配置loader]]></title>
        <id>https://just4city.github.io/post/vue-cli-30-zen-me-pei-zhi-loader</id>
        <link href="https://just4city.github.io/post/vue-cli-30-zen-me-pei-zhi-loader">
        </link>
        <updated>2019-11-25T06:51:25.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://cli.vuejs.org/zh/guide/webpack.html#%E7%AE%80%E5%8D%95%E7%9A%84%E9%85%8D%E7%BD%AE%E6%96%B9%E5%BC%8F">官方文档参考</a></p>
<p>删除并制定规则</p>
<pre><code class="language-javascript">chainWebpack: config =&gt; {
  const imagesRule = config.module.rule('images')
  imagesRule.uses.clear()
  imagesRule.use('file-loader')
    .loader('url-loader')
    .options({
      limit: 10000,
      fallback: {
        loader: 'file-loader',
        options: {
          name: 'img/[name].[hash:8].[ext]'
        }
      }
    })
}
</code></pre>
<p>修改规则</p>
<pre><code class="language-javascript">const merge = require('webpack-merge')

chainWebpack: config =&gt; {
  config.module
    .rule('images')
    .use('url-loader')
    .tap(options =&gt; {
      return merge(options, {
        limit: 10000
      })
    })
}
</code></pre>
<p><a href="https://forum.vuejs.org/t/vue-cli-3-0-loader/43308">参考1</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Nginx解决vue router的history模式下，页面刷新404]]></title>
        <id>https://just4city.github.io/post/nginx-jie-jue-vue-router-de-history-mo-shi-xia-ye-mian-shua-xin-404</id>
        <link href="https://just4city.github.io/post/nginx-jie-jue-vue-router-de-history-mo-shi-xia-ye-mian-shua-xin-404">
        </link>
        <updated>2019-11-24T07:31:27.000Z</updated>
        <summary type="html"><![CDATA[<p>在日常开发中，我们使用到vue一般会有两种路由模式，一种是hash一种是history。相较于hash又长又臭的路由地址，相信大多数人更加喜欢history模式清爽的路由格式。但同样的，history模式也存在着一些问题。</p>
]]></summary>
        <content type="html"><![CDATA[<p>在日常开发中，我们使用到vue一般会有两种路由模式，一种是hash一种是history。相较于hash又长又臭的路由地址，相信大多数人更加喜欢history模式清爽的路由格式。但同样的，history模式也存在着一些问题。</p>
<!-- more -->
<p>因为我们的应用是个单页客户端应用，如果后台没有正确的配置，当用户在浏览器直接访问http://xxx.com/user/id就会返回 404，这就不好看了。官方给出了几种解决方式如下：</p>
<pre><code class="language-bash">//Apache
&lt;IfModule mod_rewrite.c&gt;
  RewriteEngine On
  RewriteBase /
  RewriteRule ^index\.html$ - [L]
  RewriteCond %{REQUEST_FILENAME} !-f
  RewriteCond %{REQUEST_FILENAME} !-d
  RewriteRule . /index.html [L]
&lt;/IfModule&gt;

//Nginx
location / {
  try_files $uri $uri/ /index.html;
}

//Tomcat
&lt;error-page&gt;    
    &lt;error-code&gt;404&lt;/error-code&gt;    
    &lt;location&gt;/&lt;/location&gt;    
&lt;/error-page&gt; 
</code></pre>
<p><a href="https://ethan.pub/?p=897">https://ethan.pub/?p=897</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Vue:axios减少重复请求数据 keep-alive]]></title>
        <id>https://just4city.github.io/post/vueaxios-jian-shao-chong-fu-qing-qiu-shu-ju-keep-alive</id>
        <link href="https://just4city.github.io/post/vueaxios-jian-shao-chong-fu-qing-qiu-shu-ju-keep-alive">
        </link>
        <updated>2019-11-23T02:46:06.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://www.jianshu.com/p/03b9474c2dc1">https://www.jianshu.com/p/03b9474c2dc1</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[vue-cli3.0项目使用proxy跨域]]></title>
        <id>https://just4city.github.io/post/vue-cli30-xiang-mu-shi-yong-proxy-kua-yu</id>
        <link href="https://just4city.github.io/post/vue-cli30-xiang-mu-shi-yong-proxy-kua-yu">
        </link>
        <updated>2019-11-20T06:32:07.000Z</updated>
        <content type="html"><![CDATA[<p>通过vue-cli3.x版本构建的项目使用proxy和以前的项目不同，而且3.x版本构建的时候可以选用typescript了。下面记录一下如何使用proxy跨域。<br>
首先在根目录创建vue.config.js文件，这个配置文件在运行项目的时候自动加载。</p>
<pre><code class="language-javascript">// vue.config.js
module.exports = {
  devServer: {
    proxy: {
      '/api': {
        target: 'http://xxxx/device/', //对应自己的接口
        changeOrigin: true,
        ws: true,
        pathRewrite: {
          '^/api': ''
        }
      }
    }
  }
}

</code></pre>
<p>请求:</p>
<pre><code class="language-javascript">axios.get('/api/getDataPoint').then(res =&gt; {
  console.log(res)
})
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[nginx 同一个域名下部署多个工程]]></title>
        <id>https://just4city.github.io/post/nginx-tong-yi-ge-yu-ming-xia-bu-shu-duo-ge-gong-cheng</id>
        <link href="https://just4city.github.io/post/nginx-tong-yi-ge-yu-ming-xia-bu-shu-duo-ge-gong-cheng">
        </link>
        <updated>2019-11-19T14:26:24.000Z</updated>
        <content type="html"><![CDATA[<p>https://blog.csdn.net/chenhuaping007/article/details/79997901</p>
<p>https://juejin.im/post/5cfe23b3e51d4556f76e8073</p>
<p>https://juejin.im/post/5d7b72b7e51d453b386a63bc</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Docker run 命令参数及使用]]></title>
        <id>https://just4city.github.io/post/docker-run-ming-ling-can-shu-ji-shi-yong</id>
        <link href="https://just4city.github.io/post/docker-run-ming-ling-can-shu-ji-shi-yong">
        </link>
        <updated>2019-11-19T09:08:44.000Z</updated>
        <content type="html"><![CDATA[<h4 id="docker-run-创建一个新的容器并运行一个命令">Docker run ：创建一个新的容器并运行一个命令</h4>
<pre><code class="language-bash">docker run [OPTIONS] IMAGE [COMMAND] [ARG...]  
</code></pre>
<p>OPTIONS说明：</p>
<pre><code class="language-bash">Usage: docker run [OPTIONS] IMAGE [COMMAND] [ARG...]    

-d, --detach=false         指定容器运行于前台还是后台，默认为false     
-i, --interactive=false   打开STDIN，用于控制台交互    
-t, --tty=false            分配tty设备，该可以支持终端登录，默认为false    
-u, --user=&quot;&quot;              指定容器的用户    
-a, --attach=[]            登录容器（必须是以docker run -d启动的容器）  
-w, --workdir=&quot;&quot;           指定容器的工作目录   
-c, --cpu-shares=0        设置容器CPU权重，在CPU共享场景使用    
-e, --env=[]               指定环境变量，容器中可以使用该环境变量    
-m, --memory=&quot;&quot;            指定容器的内存上限    
-P, --publish-all=false    指定容器暴露的端口    
-p, --publish=[]           指定容器暴露的端口   
-h, --hostname=&quot;&quot;          指定容器的主机名    
-v, --volume=[]            给容器挂载存储卷，挂载到容器的某个目录    
--volumes-from=[]          给容器挂载其他容器上的卷，挂载到容器的某个目录  
--cap-add=[]               添加权限，权限清单详见：http://linux.die.net/man/7/capabilities    
--cap-drop=[]              删除权限，权限清单详见：http://linux.die.net/man/7/capabilities    
--cidfile=&quot;&quot;               运行容器后，在指定文件中写入容器PID值，一种典型的监控系统用法    
--cpuset=&quot;&quot;                设置容器可以使用哪些CPU，此参数可以用来容器独占CPU    
--device=[]                添加主机设备给容器，相当于设备直通    
--dns=[]                   指定容器的dns服务器    
--dns-search=[]            指定容器的dns搜索域名，写入到容器的/etc/resolv.conf文件    
--entrypoint=&quot;&quot;            覆盖image的入口点    
--env-file=[]              指定环境变量文件，文件格式为每行一个环境变量    
--expose=[]                指定容器暴露的端口，即修改镜像的暴露端口    
--link=[]                  指定容器间的关联，使用其他容器的IP、env等信息    
--lxc-conf=[]              指定容器的配置文件，只有在指定--exec-driver=lxc时使用    
--name=&quot;&quot;                  指定容器名字，后续可以通过名字进行容器管理，links特性需要使用名字    
--net=&quot;bridge&quot;             容器网络设置:  
                              bridge 使用docker daemon指定的网桥       
                              host    //容器使用主机的网络    
                              container:NAME_or_ID  &gt;//使用其他容器的网路，共享IP和PORT等网络资源    
                              none 容器使用自己的网络（类似--net=bridge），但是不进行配置   
--privileged=false         指定容器是否为特权容器，特权容器拥有所有的capabilities    
--restart=&quot;no&quot;             指定容器停止后的重启策略:  
                              no：容器退出时不重启    
                              on-failure：容器故障退出（返回值非零）时重启   
                              always：容器退出时总是重启    
--rm=false                 指定容器停止后自动删除容器(不支持以docker run -d启动的容器)    
--sig-proxy=true           设置由代理接受并处理信号，但是SIGCHLD、SIGSTOP和SIGKILL不能被代理    
</code></pre>
<h4 id="实例">实例</h4>
<p>使用docker镜像nginx:latest以后台模式启动一个容器,并将容器命名为mynginx</p>
<pre><code class="language-bash">docker run --name mynginx -d nginx:latest  
</code></pre>
<p>使用镜像nginx:latest以后台模式启动一个容器,并将容器的80端口映射到主机随机端口</p>
<pre><code class="language-bash">docker run -P -d nginx:latest    
</code></pre>
<p>使用镜像nginx:latest以后台模式启动一个容器,将容器的80端口映射到主机的80端口,主机的目录/data映射到容器的/data</p>
<pre><code class="language-bash">docker run -p 80:80 -v /data:/data -d nginx:latest     
</code></pre>
<p>使用镜像nginx:latest以交互模式启动一个容器,在容器内执行/bin/bash命令</p>
<pre><code class="language-bash">docker run -it nginx:latest /bin/bash    
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[egg.js跨域问题]]></title>
        <id>https://just4city.github.io/post/eggjs-kua-yu-wen-ti</id>
        <link href="https://just4city.github.io/post/eggjs-kua-yu-wen-ti">
        </link>
        <updated>2019-11-18T14:21:02.000Z</updated>
        <summary type="html"><![CDATA[<p>前后端分离下,egg如何设置跨域</p>
]]></summary>
        <content type="html"><![CDATA[<p>前后端分离下,egg如何设置跨域</p>
<!-- more -->
<p>不设置白名单，直接在egg跨域插件配置的origin里面指定访问域名并开启认证模式</p>
<pre><code class="language-javascript">config.cors = {
    origin:'http://ip:port',
    credentials: true,
    allowMethods: 'GET,HEAD,PUT,POST,DELETE,PATCH'
  };

</code></pre>
<p><a href="https://github.com/eggjs/egg/issues/725">https://github.com/eggjs/egg/issues/725</a></p>
]]></content>
    </entry>
</feed>